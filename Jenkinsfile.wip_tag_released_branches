// Curl site

import java.text.SimpleDateFormat

@Library('genome') _
def senseislack = new org.klick.SenseiSlack()


node('sensei_build') {

  try {

    def finalize_branches = []

    def testing_release = [
      sites: ['http://localhost:1337/'],
      code_github_org: 'jeff-zohrab',
      code_repo_name: 'klick-genome-CI-stub',
      branch_pattern: "release-\\d+",
      tag_pattern: "genome_\\d+",
      add_tag: "TESTINGTAG"
    ]
    // TODO: have this return a struct, with branches and errors member
    // so can report a slack warning if there are errors.
    finalize_branches += branches_to_finalize(testing_release)
    
    def genome_release = [
      sites: ['https://genome.klick.com/'],
      github_org: 'KlickInc',
      repo_name: 'klick-genome',
      branch_pattern: "release-\\d+",
      tag_pattern: "genome_\\d+",
      add_tag: "NEWTAGHERE"
    ]
    // finalize_branches += branches_to_finalize(genome_release)

    // TODO: Sensei launches

    debug_dump_list("Finalize", finalize_branches)
    if (finalize_branches.size() == 0) {
      echo "No release branches need tagging/merging, exiting."
      return
    }

    // https://developer.github.com/v3/repos/merging/
    echo "Try using the github API now"

    finalize_branches.each { b ->
      echo "Finalizing ${b}"
      finalize_release(b)
    }


//    githelper.add_remote(blah)
//    githelper.fetch('origin', 'develop')
//    githelper.fetch('origin', 'master')
//    finalize_branches.each { b ->
//      branch = b.object.replace('refs/heads/', '')
//      githelper.fetch('origin', branch)
//      githelper.add_tag(b.add_tag, b.sha)
//      bat "git push origin b.add_tag"
//      merge_and_push(b.add_tag, 'develop')
//      merge_and_push(b.add_tag, 'master')
//      delete(branch)
//    }

    // def msg = [ subject: 'hi', body: 'there', channel: 'jenkins-dev-tests' ]
    // senseislack.post_success(msg)

  }
  catch(err) {
    echo "FAILED: ${err}"
    currentBuild.result = 'FAILURE'
    
    // def msg = [ subject: 'failed', body: "ERROR: ${err}", channel: 'jenkins-dev-tests' ]
    // senseislack.post_failure(msg)
  }
}


///////////////////////////////////////


// Get branches needing tags and merge
def branches_to_finalize(args) {

    def untagged = get_untagged_release_branches(args)
    if (untagged.size() == 0) {
      echo "No untagged branches, exiting."
      return
    }

    def deployed = args.sites.collect { url ->
      def data = get_deployed_sha_from_manifest(url)
      [ site: url, sha: data.sha, error: data.error ]
    }

    def deployed_shas = deployed.collect { it.sha }.findAll { it != null }
    def needs_tag = untagged.findAll { b -> deployed_shas.contains(b.sha) }

    debug_dump_list("Deployed", deployed)
    debug_dump_list("Untagged but deployed", needs_tag)

    return needs_tag.collect { it.add_tag = args.add_tag; it }
}


def make_tag_name(tag_start) {
  def dateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss")
  def date = new Date()
  def tagname = tag_start + dateFormat.format(date)
  return tagname
}


// Finalize the release:
// * tag any untagged release branch that has been deployed
// * merge into develop and push
// * merge into master and push
def finalize_release(args) {
  def tag_args = [
    tag: args.add_tag,
    sha: args.sha,
    message: "Deployed",
    username: 'sensei-jenkins',
    email: 'sensei-jenkins@ci.senseilabs.com',
    code_repo_name: args.code_repo_name,
    code_github_org: args.code_github_org,
    creds_id: 'github-ci'
  ]
  // github_api_tag(tag_args)  // TODO - re-enable

  for (b in ['develop', 'master']) {
    def merge_args = [
      sha: args.sha,
      base_branch: b,
      commit_message: "Merging ${args.add_tag} into ${b}",
      code_repo_name: args.code_repo_name,
      code_github_org: args.code_github_org,
      creds_id: 'github-ci'
    ]
    github_api_merge(merge_args)
  }

  
}


// Create the new tag via the API.
//
// Refs:
// * https://stackoverflow.com/questions/15672547/how-to-tag-a-commit-in-api-using-curl-command
//   (the GitHub docs aren't v. good for this, use the above)
def github_api_tag(args) {

  def dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ss")
  def date = new Date()
  // Hardcoding 4-hour offset, couldn't get that simply in Groovy and not worth spending time on.
  def datestring = "${dateFormat.format(date)}-04:00"
  echo "DEBUG: creating tag with date = ${datestring}"
  
  def auth_token = "user:github_token"
  withCredentials([usernamePassword(credentialsId: args.creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    auth_token = "${U}:${P}"
  }

  // Note: """ multiline interpolated strings means
  // we have to escape the powershell "$" (e.g., "\$Headers = '...'").
  def script = """
\$basic_auth = 'Basic {0}' -f [System.Convert]::ToBase64String([char[]]'${auth_token}')
\$Headers = @{ Authorization = \$basic_auth };

\$params = @{
  "tag" = "${args.tag}";
  "object" = "${args.sha}";
  "message" = "${args.message}";
  "tagger" = @{
    "name" = "${args.username}";
    "email" = "${args.email}";
    "date" = "${datestring}";
  };
  "type" = "commit";
}

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
\$response = Invoke-WebRequest `
  -Headers \$Headers `
  -Uri https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/git/tags `
  -Method POST `
  -Body (\$params | ConvertTo-Json) `
  -ContentType "application/json"

write-output \$response
\$status_code = \$response | Select-Object -ExpandProperty StatusCode

\$tagsha = \$response | Select-Object -ExpandProperty sha

write-output "FINAL_StatusCode: \${status_code}"

if (\$status_code -eq '201') {
  write-output "Tag ${args.tag} created, has sha \${tagsha}"

} else {
  write-output "Tag ${args.tag} NOT CREATED"
}

"""

  def result = powershell(returnStdout: true, script: script).trim()
  echo result
  def status_code = result.
    split("\n").
    findAll { it =~ /FINAL_StatusCode/ }.
    collect { it.replace('FINAL_StatusCode: ', '') }[0]

  echo "\n\nCompleted tag creation of ${args.tag}, status code = ${status_code}"

  if (status_code != '200' && status_code != '201') {
    echo "Tag NOT CREATED, exiting."
    return
  }
  
  echo "TODO OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO add the refs tags thing"
}



/////////////////////////////////////////////////


// Merge the sha into the base branch.
//
// GitHub API only allows for merging by branch or sha.
// Refs:
// * https://developer.github.com/v3/repos/merging/
// * https://channel9.msdn.com/Blogs/trevor-powershell/Automating-the-GitHub-REST-API-Using-PowerShell
def github_api_merge(args) {
  def auth_token = "user:github_token"
  withCredentials([usernamePassword(credentialsId: args.creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    auth_token = "${U}:${P}"
  }

  def body_string = """
  {
      "base": "${args.base_branch}",
      "head": "${args.sha}",
      "commit_message": "${args.commit_message}"
  }
  """

  HttpResponse resp = this.doPostHttpRequestWithJson(body_string, "https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/merges");

  echo "RESPONSE = ${resp}"

////  def remote = new HTTPBuilder("https://api.github.com")
////  remote.request(POST) { req ->
////    uri.path = "/repos/${args.code_github_org}/${args.code_repo_name}/merges"
////    requestContentType = ContentType.JSON
////    body = [
////      base: args.base_branch,
////      head: args.sha,
////      commit_message: args.commit_message
////    ]
////    headers = ['Authorization': "Basic ${auth_token.bytes.encodeBase64().toString()}"]
////
////    response.success = { resp ->
////        println "Success! ${resp.status}"
////    }
////
////    response.failure = { resp ->
////        println "Request failed with status ${resp.status}"
////    }
////
////  }
////
////  return
////
////  // Note: """ multiline interpolated strings means
////  // we have to escape the powershell "$" (e.g., "\$Headers = '...'").
////  def script = """
////\$basic_auth = 'Basic {0}' -f [System.Convert]::ToBase64String([char[]]'${auth_token}')
////\$Headers = @{ Authorization = \$basic_auth };
////
////\$params = @{
////  "base" = "${args.base_branch}";
////  "head" = "${args.sha}";
////  "commit_message" = "${args.commit_message}";
////}
////
////[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
////\$response = Invoke-WebRequest `
////  -Headers \$Headers `
////  -Uri https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/merges `
////  -Method POST `
////  -Body (\$params | ConvertTo-Json) `
////  -ContentType "application/json"
////\$status_code = \$response | Select-Object -ExpandProperty StatusCode
////
////write-output \$response
////write-output "FINAL_StatusCode: \${status_code}"
////"""
////
////  def result = powershell(returnStdout: true, script: script).trim()
////  echo result
////  def status_code = result.
////    split("\n").
////    findAll { it =~ /FINAL_StatusCode/ }.
////    collect { it.replace('FINAL_StatusCode: ', '') }[0]
////
////  echo "\n\nCompleted merge of ${args.sha} into ${args.base_branch}, status code = ${status_code}"
}


///////////////////////////////////////////////////////////
// POWERSHELL

// Merge the sha into the base branch.
//
// GitHub API only allows for merging by branch or sha.
// Refs:
// * https://developer.github.com/v3/repos/merging/
// * https://channel9.msdn.com/Blogs/trevor-powershell/Automating-the-GitHub-REST-API-Using-PowerShell
def POWERSHELL___github_api_merge(args) {
  def auth_token = "user:github_token"
  withCredentials([usernamePassword(credentialsId: args.creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    auth_token = "${U}:${P}"
  }

  // Note: """ multiline interpolated strings means
  // we have to escape the powershell "$" (e.g., "\$Headers = '...'").
  def script = """
\$basic_auth = 'Basic {0}' -f [System.Convert]::ToBase64String([char[]]'${auth_token}')
\$Headers = @{ Authorization = \$basic_auth };

\$params = @{
  "base" = "${args.base_branch}";
  "head" = "${args.sha}";
  "commit_message" = "${args.commit_message}";
}

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
\$response = Invoke-WebRequest `
  -Headers \$Headers `
  -Uri https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/merges `
  -Method POST `
  -Body (\$params | ConvertTo-Json) `
  -ContentType "application/json"
\$status_code = \$response | Select-Object -ExpandProperty StatusCode

write-output \$response
write-output "FINAL_StatusCode: \${status_code}"
"""

  def result = powershell(returnStdout: true, script: script).trim()
  echo result
  def status_code = result.
    split("\n").
    findAll { it =~ /FINAL_StatusCode/ }.
    collect { it.replace('FINAL_StatusCode: ', '') }[0]

  echo "\n\nCompleted merge of ${args.sha} into ${args.base_branch}, status code = ${status_code}"
}


//// END POWERSHELL


def debug_dump_list(title, items) {
  def content = items.collect { "  * ${it}" }.join("\n")
  echo """-----------------
DEBUG: ${title} (${items.size()} items):
${content}
END_DEBUG: ${title}
--------------------"""
}


// Get the sha from the deployed manifest.
def get_deployed_sha_from_manifest(check_URL) {
  def result = [ sha: null, error: null ]
  
  manifest_url = "${check_URL}/manifest.json"
  try {
    // See https://stackoverflow.com/questions/1408042/output-data-with-no-column-headings-using-powershel
    // re "-ExpandProperty" flag.
    def myscript = "Invoke-WebRequest ${manifest_url} | ConvertFrom-Json | Select -ExpandProperty vcs-sha"
    def tmp = powershell(returnStdout: true, script: myscript).trim()
    if (tmp.trim().size() == 0) { tmp = null }
    result.sha = tmp
    if (result.sha == null) {
      result.error = "Null sha (missing vcs-sha from ${manifest_url} ?)"
    }
  }
  catch (err) {
    result.error = "Error getting sha from ${manifest_url}: ${err} (check the log for details)"
  }
  
  return result
}



def ls_remote_objects_matching_pattern(repo_url, object_type, pattern) {
  def cmd = "git ls-remote ${object_type} ${repo_url}"
  // I tried using <refs> to limit the output of ls-remote, but it didn't work
  // (would filter out all branches/tags).  Getting everything and filtering locally ...
  // wasteful, but it will work.
  def data = bat(returnStdout: true, script: cmd).
    split("\n").
    findAll { it =~ pattern }.       // Remove command, and empty blank lines
    findAll { !(it =~ /\^\{\}$/) }.  // ls-remote adds extra lines with "^{}" for tags
    collect { [ sha: it.split("\t")[0], object: it.split("\t")[1] ] }
  return data
}


def get_untagged_release_branches(args) {
    withCredentials([usernamePassword(credentialsId: 'github-ci', passwordVariable: 'P', usernameVariable: 'U')]) {
      def repo_url = "https://${U}:${P}@github.com/${args.code_github_org}/${args.code_repo_name}"
      def tag_regex = /refs\/tags\/${args.tag_pattern}/
      def tag_list = ls_remote_objects_matching_pattern(repo_url, '--tags', tag_regex)
      def tag_shas = tag_list.collect { it.sha }

      def branch_regex = /refs\/heads\/${args.branch_pattern}/
      def branch_list = ls_remote_objects_matching_pattern(repo_url, '--heads', branch_regex)
      def untagged_branches = branch_list.
        findAll { !(tag_shas.contains(it.sha)) }.
	collect {
	  it.code_repo_name = args.code_repo_name
	  it.code_github_org = args.code_github_org
	  it
	}

      // debug_dump_list("Tags", tag_list)
      // debug_dump_list("Tag shas", tag_shas)
      debug_dump_list("Branches", branch_list)
      debug_dump_list("Untagged branches", untagged_branches)

      return untagged_branches
    }
}
    


/////////////////////////////
// trying https://stackoverflow.com/questions/34682099/how-to-call-rest-from-jenkins-workflow/34875259

HttpResponse doGetHttpRequest(String requestUrl){    
    URL url = new URL(requestUrl);    
    HttpURLConnection connection = url.openConnection();    

    connection.setRequestMethod("GET");    

    //get the request    
    connection.connect();    

    //parse the response    
    HttpResponse resp = new HttpResponse(connection);    

    if(resp.isFailure()){    
        error("\nGET from URL: $requestUrl\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");    
    }    

    this.printDebug("Request (GET):\n  URL: $requestUrl");    
    this.printDebug("Response:\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");    

    return resp;    
}  

/**    
 * Posts the json content to the given url and ensures a 200 or 201 status on the response.    
 * If a negative status is returned, an error will be raised and the pipeline will fail.    
 */    
HttpResponse doPostHttpRequestWithJson(String json, String requestUrl){    
    return doHttpRequestWithJson(json, requestUrl, "POST");    
}    

/**    
 * Posts the json content to the given url and ensures a 200 or 201 status on the response.    
 * If a negative status is returned, an error will be raised and the pipeline will fail.    
 */    
HttpResponse doPutHttpRequestWithJson(String json, String requestUrl){    
    return doHttpRequestWithJson(json, requestUrl, "PUT");    
}

/**    
 * Post/Put the json content to the given url and ensures a 200 or 201 status on the response.    
 * If a negative status is returned, an error will be raised and the pipeline will fail.    
 * verb - PUT or POST    
 */    
HttpResponse doHttpRequestWithJson(String json, String requestUrl, String verb){    
    URL url = new URL(requestUrl);    
    HttpURLConnection connection = url.openConnection();    

    connection.setRequestMethod(verb);    
    connection.setRequestProperty("Content-Type", "application/json");    
    connection.doOutput = true;    

    //write the payload to the body of the request    
    def writer = new OutputStreamWriter(connection.outputStream);    
    writer.write(json);    
    writer.flush();    
    writer.close();    

    //post the request    
    connection.connect();    

    //parse the response    
    HttpResponse resp = new HttpResponse(connection);    

    if(resp.isFailure()){    
        error("\n$verb to URL: $requestUrl\n    JSON: $json\n    HTTP Status: $resp.statusCode\n    Message: $resp.message\n    Response Body: $resp.body");    
    }    

    this.printDebug("Request ($verb):\n  URL: $requestUrl\n  JSON: $json");    
    this.printDebug("Response:\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");    

    return resp;    
}  

class HttpResponse {    

    String body;    
    String message;    
    Integer statusCode;    
    boolean failure = false;    

    public HttpResponse(HttpURLConnection connection){    
        this.statusCode = connection.responseCode;    
        this.message = connection.responseMessage;    

        if(statusCode == 200 || statusCode == 201){    
            this.body = connection.content.text;//this would fail the pipeline if there was a 400    
        }else{    
            this.failure = true;    
            this.body = connection.getErrorStream().text;    
        }    

        connection = null; //set connection to null for good measure, since we are done with it    
    }       
}
