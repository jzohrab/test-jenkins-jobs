// Curl site

@Library('genome') _
def senseislack = new org.klick.SenseiSlack()


CODE_GITHUB_ORG = 'KlickInc'
CODE_REPO_NAME = 'klick-genome'

CODE_GITHUB_ORG = 'jeff-zohrab'
CODE_REPO_NAME = 'klick-genome-CI-stub'


node('sensei_build') {

  try {

    def finalize_branches = []

    def testing_release = [
      sites: ['http://localhost:1337/'],
      code_github_org: 'jeff-zohrab',
      code_repo_name: 'klick-genome-CI-stub',
      branch_pattern: "release-\\d+",
      tag_pattern: "genome_\\d+",
      add_tag: "TESTINGTAG"
    ]
    // TODO: have this return a struct, with branches and errors member
    // so can report a slack warning if there are errors.
    finalize_branches += branches_to_finalize(testing_release)
    
    def genome_release = [
      sites: ['https://genome.klick.com/'],
      github_org: 'KlickInc',
      repo_name: 'klick-genome',
      branch_pattern: "release-\\d+",
      tag_pattern: "genome_\\d+",
      add_tag: "NEWTAGHERE"
    ]
    // finalize_branches += branches_to_finalize(genome_release)

    // TODO: Sensei launches

    debug_dump_list("Finalize", finalize_branches)
    if (finalize_branches.size() == 0) {
      echo "No release branches need tagging/merging, exiting."
      return
    }

    // https://developer.github.com/v3/repos/merging/
    echo "Try using the github API now"

    // https://channel9.msdn.com/Blogs/trevor-powershell/Automating-the-GitHub-REST-API-Using-PowerShell
    finalize_branches.each { b ->
      echo "Finalizing ${b}"
      finalize_release(b)
    }


//    githelper.add_remote(blah)
//    githelper.fetch('origin', 'develop')
//    githelper.fetch('origin', 'master')
//    finalize_branches.each { b ->
//      branch = b.object.replace('refs/heads/', '')
//      githelper.fetch('origin', branch)
//      githelper.add_tag(b.add_tag, b.sha)
//      bat "git push origin b.add_tag"
//      merge_and_push(b.add_tag, 'develop')
//      merge_and_push(b.add_tag, 'master')
//      delete(branch)
//    }

    // def msg = [ subject: 'hi', body: 'there', channel: 'jenkins-dev-tests' ]
    // senseislack.post_success(msg)

  }
  catch(err) {
    echo "FAILED: ${err}"
    currentBuild.result = 'FAILURE'
    
    // def msg = [ subject: 'failed', body: "ERROR: ${err}", channel: 'jenkins-dev-tests' ]
    // senseislack.post_failure(msg)
  }
}


///////////////////////////////////////


// Get branches needing tags and merge
def branches_to_finalize(args) {

    def untagged = get_untagged_release_branches(args)
    if (untagged.size() == 0) {
      echo "No untagged branches, exiting."
      return
    }

    def deployed = args.sites.collect { url ->
      def data = get_deployed_sha_from_manifest(url)
      [ site: url, sha: data.sha, error: data.error ]
    }

    def deployed_shas = deployed.collect { it.sha }.findAll { it != null }
    def needs_tag = untagged.findAll { b -> deployed_shas.contains(b.sha) }

    debug_dump_list("Deployed", deployed)
    debug_dump_list("Untagged but deployed", needs_tag)

    return needs_tag.collect { it.add_tag = args.add_tag; it }
}


// Finalize the release:
// * tag any untagged release branch that has been deployed
// * merge into develop and push
// * merge into master and push
def finalize_release(args) {
  def github_merge_powershell = ""
  def uri = "https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/merges"

  def myscript = ""
  withCredentials([usernamePassword(credentialsId: 'github-ci', passwordVariable: 'P', usernameVariable: 'U')]) {
    myscript = """
\$Base64Token = [System.Convert]::ToBase64String([char[]]'${U}:${P}');
\$Headers = @{ Authorization = 'Basic {0}' -f \$Base64Token };
\$params = @{
    "base" = "master";
    "head" = "${args.add_tag}";
    "commit_message" = "merging tag";
  } | ConvertTo-Json

Invoke-WebRequest -Uri ${uri} -Method POST -Body \$params -ContentType "application/json"
"""
  } // end with
  def tmp = powershell(returnStdout: true, script: myscript).trim()
  echo tmp
}


def debug_dump_list(title, items) {
  def content = items.collect { "  * ${it}" }.join("\n")
  echo """-----------------
DEBUG: ${title} (${items.size()} items):
${content}
END_DEBUG: ${title}
--------------------"""
}



// Get the sha from the deployed manifest.
def get_deployed_sha_from_manifest(check_URL) {
  def result = [ sha: null, error: null ]
  
  manifest_url = "${check_URL}/manifest.json"
  try {
    // See https://stackoverflow.com/questions/1408042/output-data-with-no-column-headings-using-powershel
    // re "-ExpandProperty" flag.
    def myscript = "Invoke-WebRequest ${manifest_url} | ConvertFrom-Json | Select -ExpandProperty vcs-sha"
    def tmp = powershell(returnStdout: true, script: myscript).trim()
    if (tmp.trim().size() == 0) { tmp = null }
    result.sha = tmp
    if (result.sha == null) {
      result.error = "Null sha (missing vcs-sha from ${manifest_url} ?)"
    }
  }
  catch (err) {
    result.error = "Error getting sha from ${manifest_url}: ${err} (check the log for details)"
  }
  
  return result
}



def ls_remote_objects_matching_pattern(repo_url, object_type, pattern) {
  def cmd = "git ls-remote ${object_type} ${repo_url}"
  // I tried using <refs> to limit the output of ls-remote, but it didn't work
  // (would filter out all branches/tags).  Getting everything and filtering locally ...
  // wasteful, but it will work.
  def data = bat(returnStdout: true, script: cmd).
    split("\n").
    findAll { it =~ pattern }.       // Remove command, and empty blank lines
    findAll { !(it =~ /\^\{\}$/) }.  // ls-remote adds extra lines with "^{}" for tags
    collect { [ sha: it.split("\t")[0], object: it.split("\t")[1] ] }
  return data
}


def get_untagged_release_branches(args) {
    withCredentials([usernamePassword(credentialsId: 'github-ci', passwordVariable: 'P', usernameVariable: 'U')]) {
      def repo_url = "https://${U}:${P}@github.com/${args.code_github_org}/${args.code_repo_name}"
      def tag_regex = /refs\/tags\/${args.tag_pattern}/
      def tag_list = ls_remote_objects_matching_pattern(repo_url, '--tags', tag_regex)
      def tag_shas = tag_list.collect { it.sha }

      def branch_regex = /refs\/heads\/${args.branch_pattern}/
      def branch_list = ls_remote_objects_matching_pattern(repo_url, '--heads', branch_regex)
      def untagged_branches = branch_list.
        findAll { !(tag_shas.contains(it.sha)) }.
	collect {
	  it.code_repo_name = args.code_repo_name
	  it.code_github_org = args.code_github_org
	  it
	}

      // debug_dump_list("Tags", tag_list)
      // debug_dump_list("Tag shas", tag_shas)
      debug_dump_list("Branches", branch_list)
      debug_dump_list("Untagged branches", untagged_branches)

      return untagged_branches
    }
}
    

