// Curl site

@Library('genome') _
def senseislack = new org.klick.SenseiSlack()


CODE_GITHUB_ORG = 'KlickInc'
CODE_REPO_NAME = 'klick-genome'


node('sensei_build') {

  try {

    finalize_branches = []
    
    genome_release = [
      sites: ['https://genome.klick.com/'],
      branch_pattern: "release-\\d+",
      tag_pattern: "genome_\\d+",
      add_tag: "NEWTAGHERE"
    ]
    finalize_branches << branches_to_finalize(genome_release)

    // TODO: Sensei launches
    
    if (finalize_branches.size() == 0) {
      echo "No release branches need tagging/merging, exiting."
      return
    }


    // def msg = [ subject: 'hi', body: 'there', channel: 'jenkins-dev-tests' ]
    // senseislack.post_success(msg)

  }
  catch(err) {
    echo "FAILED: ${err}"
    currentBuild.result = 'FAILURE'
    
    // def msg = [ subject: 'failed', body: "ERROR: ${err}", channel: 'jenkins-dev-tests' ]
    // senseislack.post_failure(msg)
  }
}


///////////////////////////////////////


// Get branches needing tags and merge
def branches_to_finalize(args) {

    def untagged = get_untagged_release_branches(args.branch_pattern, args.tag_pattern)
    if (untagged.size() == 0) {
      echo "No untagged branches, exiting."
      return
    }

    def deployed = args.sites.collect { url ->
      def data = get_deployed_sha_from_manifest(url)
      [ site: url, sha: data.sha, error: data.error ]
    }

    def deployed_shas = deployed.collect { it.sha }.findAll { it != null }
    def needs_tag = untagged.findAll { b -> deployed_shas.contains(b.sha) }

    debug_dump_list("Deployed", deployed)
    debug_dump_list("Untagged but deployed", needs_tag)

    return needs_tag.collect { it.add_tag = args.add_tag; it }
}


// Finalize the release:
// * tag any untagged release branch that has been deployed
// * merge into develop and push
// * merge into master and push
def finalize_release(args) {
  echo "TODO"
}


def debug_dump_list(title, items) {
  echo "DEBUG: ${title}"
  echo items.collect { "* ${it}" }.join("\n")
  echo "END_DEBUG: ${title}"
}



// Get the sha from the deployed manifest.
def get_deployed_sha_from_manifest(check_URL) {
  def result = [ sha: null, error: null ]
  
  manifest_url = "${check_URL}/manifest.json"
  try {
    // See https://stackoverflow.com/questions/1408042/output-data-with-no-column-headings-using-powershel
    // re "-ExpandProperty" flag.
    def myscript = "Invoke-WebRequest ${manifest_url} | ConvertFrom-Json | Select -ExpandProperty vcs-sha"
    def tmp = powershell(returnStdout: true, script: myscript).trim()
    if (tmp.trim().size() == 0) { tmp = null }
    result.sha = tmp
    if (result.sha == null) {
      result.error = "Null sha (missing vcs-sha from ${manifest_url} ?)"
    }
  }
  catch (err) {
    result.error = "Error getting sha from ${manifest_url}: ${err} (check the log for details)"
  }
  return result
}



def ls_remote_objects_matching_pattern(repo_url, object_type, pattern) {
  def cmd = "git ls-remote ${object_type} ${repo_url}"
  // I tried using <refs> to limit the output of ls-remote, but it didn't work
  // (would filter out all branches/tags).  Getting everything and filtering locally ...
  // wasteful, but it will work.
  def data = bat(returnStdout: true, script: cmd).
    split("\n").
    findAll { it =~ pattern }.       // Remove command, and empty blank lines
    findAll { !(it =~ /\^\{\}$/) }.  // ls-remote adds extra lines with "^{}" for tags
    collect { [ sha: it.split("\t")[0], object: it.split("\t")[1] ] }
  return data
}


def get_untagged_release_branches(branch_pattern, tag_pattern) {
    withCredentials([usernamePassword(credentialsId: 'github-ci', passwordVariable: 'P', usernameVariable: 'U')]) {
      def repo_url = "https://${U}:${P}@github.com/${CODE_GITHUB_ORG}/${CODE_REPO_NAME}"
      def tag_list = ls_remote_objects_matching_pattern(repo_url, '--tags', /refs\/tags\/${tag_pattern}/)
      def tag_shas = tag_list.collect { it.sha }
      def branch_list = ls_remote_objects_matching_pattern(repo_url, '--heads', /refs\/heads\/${branch_pattern}/)
      def untagged_branches = branch_list.findAll { !(tag_shas.contains(it.sha)) }

      // debug_dump_list("Tags", tag_list)
      // debug_dump_list("Tag shas", tag_shas)
      debug_dump_list("Branches", branch_list)
      debug_dump_list("Untagged branches", untagged_branches)

      return untagged_branches
    }
}
    

