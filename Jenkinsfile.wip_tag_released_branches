// Check repositories

import java.text.SimpleDateFormat
import groovy.json.JsonSlurper

@Library('genome') _
def senseislack = new org.klick.SenseiSlack()

SLACK_CHANNEL = 'jenkins-dev-tests'  // TODO change this

node('sensei_build') {

  try {

    def finalize_branches = []

    stage('Get release branches') {
      finalize_branches += test_release_branches()
      finalize_branches += genome_release_branches()
      finalize_branches += sensei_release_branches()
    }

    stage('Finalize branches') {
      debug_dump_list("Finalize", finalize_branches)
      if (finalize_branches.size() == 0) {
        echo "No release branches need tagging/merging, exiting."
      }
  
      finalize_branches.each { b ->
        try {
          echo "Finalizing ${b}"
          finalize_release(b)
          send_finalized_success_slack(b)
        }
        catch(err) {
          echo "Error finalizing ${b}:\n${err}"
          send_finalized_failure_slack(b, err)
          currentBuild.result = 'FAILURE'
        }
      }

    }

  }
  catch(err) {
    echo "FAILED: ${err}"
    currentBuild.result = 'FAILURE'
    def msg = [ subject: 'failed', body: "ERROR: ${err}", channel: SLACK_CHANNEL ]
    senseislack.post_failure(msg)
  }
}


///////////////////////////////////////
// Utils

def make_tag_name(tag_start) {
  def dateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss")
  def date = new Date()
  def tagname = tag_start + dateFormat.format(date)
  return tagname
}


def debug_dump_list(title, items) {
  def content = items.collect { "  * ${it}" }.join("\n")
  if (content.size() == 0) { content = "  (no items)" }
  echo """-----------------
DEBUG: ${title} (${items.size()} items):
${content}
--------------------"""
}


////////////////////////////////////////////////
// Find release branches that may need to be finalized

def test_release_branches() {
  def testing_release = [
    sites: ['http://localhost:1337/'],
    code_github_org: 'jeff-zohrab',
    code_repo_name: 'klick-genome-CI-stub',
    branch_pattern: "release-\\d+",
    tag_pattern: "genome_\\d+",
    add_tag: make_tag_name("genome_")
  ]
  return branches_to_finalize(testing_release)
}

def genome_release_branches() {
  def genome_release = [
    sites: ['https://genome.klick.com/'],
    code_github_org: 'KlickInc',
    code_repo_name: 'klick-genome',
    branch_pattern: "release-\\d+",
    tag_pattern: "genome_\\d+",
    add_tag: make_tag_name("genome_")
  ]
  return branches_to_finalize(genome_release)
}

def sensei_release_branches() {
  def sensei_release = [
    sites: [
      'https://uzone.unitedshore.com/',
      'https://rellyant.senseilabs.com/',
      'https://base-staging.senseilabs.com/',
      'https://suncorp.senseilabs.com/',
      'https://atk-demo.senseilabs.com/',
      'https://liberty.senseilabs.com/'
    ],
    code_github_org: 'KlickInc',
    code_repo_name: 'klick-genome',
    branch_pattern: "release-sensei-\\d+",
    tag_pattern: "GA_\\d+",
    add_tag: make_tag_name("GA_")
  ]
  return branches_to_finalize(sensei_release)
}


// Get branches that need to be tagged and merged
def branches_to_finalize(args) {
  def untagged = get_untagged_release_branches(args)
  if (untagged.size() == 0) {
    echo "No untagged branches, exiting."
    return []
  }

  def deployed = args.sites.collect { url ->
    def data = get_deployed_sha_from_manifest(url)
    [ site: url, sha: data.sha, error: data.error ]
  }
  debug_dump_list("Deployed", deployed)

  // If every manifest lookup failed, we're in trouble.
  if (deployed.findAll { it.error == null }.size() == 0) {
    def msg = deployed.collect { " * ${it.site}: ${it.error}" }.join("\n")
    error "All sha lookups failed!\n${msg}"
  }

  def deployed_shas = deployed.collect { it.sha }.findAll { it != null }
  def needs_tag = untagged.findAll { b -> deployed_shas.contains(b.sha) }
  debug_dump_list("Untagged but deployed", needs_tag)

  return needs_tag.collect { it.add_tag = args.add_tag; it }
}



def get_untagged_release_branches(args) {
  def repo_url = ""
  withCredentials([usernamePassword(credentialsId: 'github-ci', passwordVariable: 'P', usernameVariable: 'U')]) {
    repo_url = "https://${U}:${P}@github.com/${args.code_github_org}/${args.code_repo_name}"
  }
    
  def tag_regex = /refs\/tags\/${args.tag_pattern}/
  def tag_list = ls_remote_objects_matching_pattern(repo_url, '--tags', tag_regex)
  def tag_shas = tag_list.collect { it.sha }

  def branch_regex = /refs\/heads\/${args.branch_pattern}/
  def branch_list = ls_remote_objects_matching_pattern(repo_url, '--heads', branch_regex)
  def tagged_branches = branch_list.findAll { (tag_shas.contains(it.sha)) }
  def untagged_branches = branch_list.
    findAll { !(tag_shas.contains(it.sha)) }.
    collect {
      it.code_repo_name = args.code_repo_name
      it.code_github_org = args.code_github_org
      it
    }

  // debug_dump_list("Tags matching ${tag_regex}", tag_list)
  // debug_dump_list("Tag shas", tag_shas)
  debug_dump_list("All branches matching ${branch_regex}", branch_list)
  debug_dump_list("Branches matching ${branch_regex}, already tagged with ${tag_regex}", tagged_branches)
  debug_dump_list("Branches matching ${branch_regex}, NOT YET tagged with ${tag_regex}", untagged_branches)

  return untagged_branches
}


def ls_remote_objects_matching_pattern(repo_url, object_type, pattern) {
  def cmd = "git ls-remote ${object_type} ${repo_url}"
  // I tried using <refs> to limit the output of ls-remote, but it didn't work
  // (would filter out all branches/tags).  Getting everything and filtering locally ...
  // wasteful, but it will work.
  def data = bat(returnStdout: true, script: cmd).
    split("\n").
    findAll { it =~ pattern }

  // Git ls-remote returns two lines for tags, eg:
  //   788...  refs/tags/genome_20180522_220000
  //   a0d... refs/tags/genome_20180522_220000^{}
  // The line ending with "^{}" is what the tag references, the other
  // is the sha of the tag itself.
  // We only care about the reference!
  if (object_type == '--tags') {
    data = data.findAll { it =~ /\^\{\}$/ }
  }

  return data.collect { [ sha: it.split("\t")[0], object: it.split("\t")[1] ] }
}


////////////////////////////////////////////////
// Manifest sha lookup

// Get the sha from the deployed manifest.
def get_deployed_sha_from_manifest(check_URL) {
  def result = [ sha: null, error: null ]

  manifest_url = "${check_URL}/manifest.json"
  echo "Checking ${manifest_url}"
  try {
    // See https://stackoverflow.com/questions/1408042/
    //   output-data-with-no-column-headings-using-powershel
    // for notes on the "-ExpandProperty" flag.
    def myscript = "Invoke-WebRequest ${manifest_url} | ConvertFrom-Json | Select -ExpandProperty vcs-sha"

    def tmp = powershell(returnStdout: true, script: myscript).trim()
    if (tmp.trim().size() == 0) { tmp = null }
    result.sha = tmp
    if (result.sha == null) {
      result.error = "Null sha (missing vcs-sha from ${manifest_url} ?)"
    }
  }
  catch (err) {
    result.error = "Error getting sha from ${manifest_url}: ${err} (check Jenkins log for details)"
  }

  return result
}


////////////////////////////////////////////////
// Finalize the release

// Finalize
// * tag any untagged release branch that has been deployed
// * merge into develop and push
// * merge into master and push
// * delete the unneeded branch
def finalize_release(args) {
  def tag_args = [
    tag: args.add_tag,
    sha: args.sha,
    message: "Deployed",
    username: 'sensei-jenkins',
    email: 'sensei-jenkins@ci.senseilabs.com',
    code_repo_name: args.code_repo_name,
    code_github_org: args.code_github_org,
    creds_id: 'github-ci'
  ]
  github_api_tag(tag_args)

  def branch_name = args.object.replace('refs/heads/', '')

  for (b in ['develop', 'master']) {
    def merge_args = [
      sha: args.sha,
      base_branch: b,
      commit_message: "Merge ${branch_name} (tag ${args.add_tag}) into ${b}",
      code_repo_name: args.code_repo_name,
      code_github_org: args.code_github_org,
      creds_id: 'github-ci'
    ]
    github_api_merge(merge_args)
  }

  def delete_args = [
    branch: branch_name,
    code_repo_name: args.code_repo_name,
    code_github_org: args.code_github_org,
    creds_id: 'github-ci'
  ]
  github_api_delete_branch(delete_args)

}


/////////////////////////////
// Slack

def send_finalized_success_slack(b) {
  def branch = b.object.replace('refs/heads/', '')
  def message = """`${branch}` (${b.code_repo_name}) tagged `${b.add_tag}`,
merged into `master` and `develop`, and deleted.
"""

  def msg = [ subject: "Finalize ${branch}", body: message, channel: SLACK_CHANNEL ]
  def senseislack = new org.klick.SenseiSlack()
  senseislack.post_success(msg)
}


def send_finalized_failure_slack(b, err) {
  def branch = b.object.replace('refs/heads/', '')
  def message = "Error: ${err}"
  def msg = [ subject: "Finalize ${branch} failed", body: message, channel: SLACK_CHANNEL ]
  def senseislack = new org.klick.SenseiSlack()
  senseislack.post_failure(msg)
}



/////////////////////////////
// GitHub API calls


def get_token(creds_id) {
  def auth_token = "user:github_token"
  withCredentials([usernamePassword(credentialsId: creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    auth_token = "${U}:${P}"
  }
  return auth_token
}


// Create the new tag via the API.
//
// Refs:
// * https://stackoverflow.com/questions/15672547/
//     how-to-tag-a-commit-in-api-using-curl-command
//   (the GitHub docs aren't good for this, above is better)
def github_api_tag(args) {

  def dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ss")
  def date = new Date()
  // Hardcoding 4-hour offset, couldn't get that simply in Groovy
  // and it's not worth spending time on.
  def datestring = "${dateFormat.format(date)}-04:00"

  def uri = "https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/git/tags"
  def body_string = """
{
  "tag": "${args.tag}",
  "object": "${args.sha}",
  "message": "${args.message}",
  "tagger": {
    "name": "${args.username}",
    "email": "${args.email}",
    "date": "${datestring}"
  },
  "type": "commit"
}
  """

  def auth_token = get_token(args.creds_id)
  HttpResponse resp
  try {
    resp = this.doPostHttpRequestWithJson(auth_token, body_string, uri);
  }
  catch (err) {
    error "Failed to create tag ('${args.tag}'): ${err}"
  }

  echo "Got code: ${resp.statusCode}"
  echo "Completed tag creation of ${args.tag}"

  if (resp.statusCode != 201) {
    echo "Tag NOT CREATED, exiting."
    return
  }

  def slurper = new groovy.json.JsonSlurper()
  def newtagresult = slurper.parseText(resp.body)
  echo "Got sha of the new tag = ${newtagresult.sha}"

  uri = "https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/git/refs"
  body_string = """
{
  "ref": "refs/tags/${args.tag}",
  "sha": "${newtagresult.sha}"
}
  """

  resp = null
  try {
    resp = this.doPostHttpRequestWithJson(auth_token, body_string, uri);
  }
  catch (err) {
    error "Failed to create ref for tag '${args.tag}': ${err}"
  }

  echo "Completed tag and ref creation of ${args.tag}"
}



// Merge the sha into the base branch.
//
// GitHub API only allows for merging by branch or sha.
// Ref https://developer.github.com/v3/repos/merging/
def github_api_merge(args) {
  def uri = "https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/merges"
  def body_string = """
  {
      "base": "${args.base_branch}",
      "head": "${args.sha}",
      "commit_message": "${args.commit_message}"
  }
  """

  def auth_token = get_token(args.creds_id)
  HttpResponse resp
  try {
    resp = this.doPostHttpRequestWithJson(auth_token, body_string, uri);
  }
  catch (err) {
    error "Failed during merge ('${args.commit_message}'): ${err}"
  }

  echo "Merged ${args.sha} into ${args.base_branch}"
}


// Delete branch.
//
// Ref https://developer.github.com/v3/git/refs/#delete-a-reference
def github_api_delete_branch(args) {
  echo "DELETING: ${args}"

  def uri = "https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/git/refs/heads/${args.branch}"

  def auth_token = get_token(args.creds_id)
  HttpResponse resp
  try {
    resp = this.doDeleteHttpRequest(auth_token, uri);
  }
  catch (err) {
    error "Failed during delete of ${args.branch}: ${err}"
  }

  echo "Deleted ${args.branch}"
}


////////////////////////////////////
// Native Groovy REST calls
// per https://stackoverflow.com/questions/34682099/how-to-call-rest-from-jenkins-workflow/34875259

HttpResponse doGetHttpRequest(String requestUrl){
  URL url = new URL(requestUrl);
  HttpURLConnection connection = url.openConnection();

  connection.setRequestMethod("GET");

  //get the request
  connection.connect();

  //parse the response
  HttpResponse resp = new HttpResponse(connection);

  if(resp.isFailure()){
      error("\nGET from URL: $requestUrl\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");
  }

  echo("Request (GET):\n  URL: $requestUrl");
  echo("Response:\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");

  return resp;
}


HttpResponse doDeleteHttpRequest(String auth_token, String requestUrl){
  URL url = new URL(requestUrl);
  HttpURLConnection connection = url.openConnection();

  def basic_auth = "Basic ${auth_token.bytes.encodeBase64().toString()}"
  connection.setRequestProperty("Authorization", basic_auth);
  connection.setRequestMethod("DELETE");

  connection.connect();

  HttpResponse resp = new HttpResponse(connection);

  if(resp.isFailure()){
      error("\nDELETE from URL: $requestUrl\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");
  }

  echo("Request (DELETE):\n  URL: $requestUrl");
  echo("Response:\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");

  return resp;
}


/**
 * Posts the json content to the given url, ensures a 2xx status on the response.
 * If a negative status is returned, an error will be raised and the pipeline will fail.
 */
HttpResponse doPostHttpRequestWithJson(String auth_token, String json, String requestUrl){
  return doHttpRequestWithJson(auth_token, json, requestUrl, "POST");
}

/**
 * Posts the json content to the given url, ensures a 2xx status on the response.
 * If a negative status is returned, an error will be raised and the pipeline will fail.
 */
HttpResponse doPutHttpRequestWithJson(String json, String requestUrl){
  return doHttpRequestWithJson(json, requestUrl, "PUT");
}

/**
 * Post/Put the json content to the given url, ensures a 2xx status on the response.
 * If a negative status is returned, an error will be raised and the pipeline will fail.
 * verb - PUT or POST
 */
HttpResponse doHttpRequestWithJson(String auth_token, String json, String requestUrl, String verb){
  URL url = new URL(requestUrl);
  HttpURLConnection connection = url.openConnection();

  connection.setRequestMethod(verb);
  def basic_auth = "Basic ${auth_token.bytes.encodeBase64().toString()}"
  connection.setRequestProperty("Content-Type", "application/json");
  connection.setRequestProperty("Authorization", basic_auth);
  connection.doOutput = true;

  //write the payload to the body of the request
  def writer = new OutputStreamWriter(connection.outputStream);
  writer.write(json);
  writer.flush();
  writer.close();

  //post the request
  connection.connect();

  //parse the response
  HttpResponse resp = new HttpResponse(connection);

  connection = null;

  if(resp.isFailure()) {
    error("\n$verb to URL: $requestUrl\n    JSON: $json\n    HTTP Status: $resp.statusCode\n    Message: $resp.message\n    Response Body: $resp.body");
  }

  echo("Request ($verb):\n  URL: $requestUrl\n  JSON: $json");
  echo("Response:\n  HTTP Status: $resp.statusCode\n  Message: $resp.message\n  Response Body: $resp.body");

  return resp;
}


class HttpResponse {

  String body;
  String message;
  Integer statusCode;
  boolean failure = false;

  public HttpResponse(HttpURLConnection connection){
    this.statusCode = connection.responseCode;
    this.message = connection.responseMessage;

    if ( statusCode >= 200 && statusCode < 300 ) {
      //this would fail the pipeline if there was a 400
      this.body = connection.content.text;
    } else {
      this.failure = true;
      this.body = connection.getErrorStream().text;
    }
  }
}
