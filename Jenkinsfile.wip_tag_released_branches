// Curl site

@Library('genome') _
def senseislack = new org.klick.SenseiSlack()


CODE_GITHUB_ORG = 'KlickInc'
CODE_REPO_NAME = 'klick-genome'

CODE_GITHUB_ORG = 'jeff-zohrab'
CODE_REPO_NAME = 'klick-genome-CI-stub'


node('sensei_build') {

  try {

    def finalize_branches = []

    def testing_release = [
      sites: ['http://localhost:1337/'],
      code_github_org: 'jeff-zohrab',
      code_repo_name: 'klick-genome-CI-stub',
      branch_pattern: "release-\\d+",
      tag_pattern: "genome_\\d+",
      add_tag: "TESTINGTAG"
    ]
    // TODO: have this return a struct, with branches and errors member
    // so can report a slack warning if there are errors.
    finalize_branches += branches_to_finalize(testing_release)
    
    def genome_release = [
      sites: ['https://genome.klick.com/'],
      github_org: 'KlickInc',
      repo_name: 'klick-genome',
      branch_pattern: "release-\\d+",
      tag_pattern: "genome_\\d+",
      add_tag: "NEWTAGHERE"
    ]
    // finalize_branches += branches_to_finalize(genome_release)

    // TODO: Sensei launches

    debug_dump_list("Finalize", finalize_branches)
    if (finalize_branches.size() == 0) {
      echo "No release branches need tagging/merging, exiting."
      return
    }

    // https://developer.github.com/v3/repos/merging/
    echo "Try using the github API now"

    finalize_branches.each { b ->
      echo "Finalizing ${b}"
      finalize_release(b)
    }


//    githelper.add_remote(blah)
//    githelper.fetch('origin', 'develop')
//    githelper.fetch('origin', 'master')
//    finalize_branches.each { b ->
//      branch = b.object.replace('refs/heads/', '')
//      githelper.fetch('origin', branch)
//      githelper.add_tag(b.add_tag, b.sha)
//      bat "git push origin b.add_tag"
//      merge_and_push(b.add_tag, 'develop')
//      merge_and_push(b.add_tag, 'master')
//      delete(branch)
//    }

    // def msg = [ subject: 'hi', body: 'there', channel: 'jenkins-dev-tests' ]
    // senseislack.post_success(msg)

  }
  catch(err) {
    echo "FAILED: ${err}"
    currentBuild.result = 'FAILURE'
    
    // def msg = [ subject: 'failed', body: "ERROR: ${err}", channel: 'jenkins-dev-tests' ]
    // senseislack.post_failure(msg)
  }
}


///////////////////////////////////////


// Get branches needing tags and merge
def branches_to_finalize(args) {

    def untagged = get_untagged_release_branches(args)
    if (untagged.size() == 0) {
      echo "No untagged branches, exiting."
      return
    }

    def deployed = args.sites.collect { url ->
      def data = get_deployed_sha_from_manifest(url)
      [ site: url, sha: data.sha, error: data.error ]
    }

    def deployed_shas = deployed.collect { it.sha }.findAll { it != null }
    def needs_tag = untagged.findAll { b -> deployed_shas.contains(b.sha) }

    debug_dump_list("Deployed", deployed)
    debug_dump_list("Untagged but deployed", needs_tag)

    return needs_tag.collect { it.add_tag = args.add_tag; it }
}


// Finalize the release:
// * tag any untagged release branch that has been deployed
// * merge into develop and push
// * merge into master and push
def finalize_release(args) {
  for (b in ['develop', 'master']) {
    def merge_args = [
      sha: args.sha,
      base_branch: b,
      commit_message: "Merging ${args.add_tag} into ${b}",
      code_repo_name: args.code_repo_name,
      code_github_org: args.code_github_org,
      creds_id: 'github-ci'
    ]
    github_api_merge(merge_args)
  }
}



// Merge the sha into the base branch.
//
// GitHub API only allows for merging by branch or sha.
// Refs:
// * https://developer.github.com/v3/repos/merging/
// * https://channel9.msdn.com/Blogs/trevor-powershell/Automating-the-GitHub-REST-API-Using-PowerShell
def github_api_merge(args) {
  def uri = "https://api.github.com/repos/${args.code_github_org}/${args.code_repo_name}/merges"
  def auth_token = "user:github_token"
  withCredentials([usernamePassword(credentialsId: args.creds_id, passwordVariable: 'P', usernameVariable: 'U')]) {
    auth_token = "${U}:${P}"
  }

  // Note: """ multiline interpolated strings means
  // we have to escape the powershell "$" (e.g., "\$Headers = '...'").
  def merge_script = """
\$basic_auth = 'Basic {0}' -f [System.Convert]::ToBase64String([char[]]'${auth_token}')
\$Headers = @{ Authorization = \$basic_auth };

\$params = @{
  "base" = "${args.base_branch}";
  "head" = "${args.sha}";
  "commit_message" = "${args.commit_message}";
}

# Use TLS 1.2 (ref https://stackoverflow.com/questions/41618766/)
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
\$response = Invoke-WebRequest `
  -Headers \$Headers `
  -Uri ${uri} `
  -Method POST `
  -Body (\$params | ConvertTo-Json) `
  -ContentType "application/json"
\$status_code = \$response | Select-Object -ExpandProperty StatusCode

write-output \$response
write-output "FINAL_StatusCode: \${status_code}"
"""

  def result = powershell(returnStdout: true, script: merge_script).trim()
  echo result
  def status_code = result.
    split("\n").
    findAll { it =~ /FINAL_StatusCode/ }.
    collect { it.replace('FINAL_StatusCode: ', '') }[0]

  echo "\n\nCompleted merge of ${args.sha} into ${args.base_branch}, status code = ${status_code}"
}


def debug_dump_list(title, items) {
  def content = items.collect { "  * ${it}" }.join("\n")
  echo """-----------------
DEBUG: ${title} (${items.size()} items):
${content}
END_DEBUG: ${title}
--------------------"""
}



// Get the sha from the deployed manifest.
def get_deployed_sha_from_manifest(check_URL) {
  def result = [ sha: null, error: null ]
  
  manifest_url = "${check_URL}/manifest.json"
  try {
    // See https://stackoverflow.com/questions/1408042/output-data-with-no-column-headings-using-powershel
    // re "-ExpandProperty" flag.
    def myscript = "Invoke-WebRequest ${manifest_url} | ConvertFrom-Json | Select -ExpandProperty vcs-sha"
    def tmp = powershell(returnStdout: true, script: myscript).trim()
    if (tmp.trim().size() == 0) { tmp = null }
    result.sha = tmp
    if (result.sha == null) {
      result.error = "Null sha (missing vcs-sha from ${manifest_url} ?)"
    }
  }
  catch (err) {
    result.error = "Error getting sha from ${manifest_url}: ${err} (check the log for details)"
  }
  
  return result
}



def ls_remote_objects_matching_pattern(repo_url, object_type, pattern) {
  def cmd = "git ls-remote ${object_type} ${repo_url}"
  // I tried using <refs> to limit the output of ls-remote, but it didn't work
  // (would filter out all branches/tags).  Getting everything and filtering locally ...
  // wasteful, but it will work.
  def data = bat(returnStdout: true, script: cmd).
    split("\n").
    findAll { it =~ pattern }.       // Remove command, and empty blank lines
    findAll { !(it =~ /\^\{\}$/) }.  // ls-remote adds extra lines with "^{}" for tags
    collect { [ sha: it.split("\t")[0], object: it.split("\t")[1] ] }
  return data
}


def get_untagged_release_branches(args) {
    withCredentials([usernamePassword(credentialsId: 'github-ci', passwordVariable: 'P', usernameVariable: 'U')]) {
      def repo_url = "https://${U}:${P}@github.com/${args.code_github_org}/${args.code_repo_name}"
      def tag_regex = /refs\/tags\/${args.tag_pattern}/
      def tag_list = ls_remote_objects_matching_pattern(repo_url, '--tags', tag_regex)
      def tag_shas = tag_list.collect { it.sha }

      def branch_regex = /refs\/heads\/${args.branch_pattern}/
      def branch_list = ls_remote_objects_matching_pattern(repo_url, '--heads', branch_regex)
      def untagged_branches = branch_list.
        findAll { !(tag_shas.contains(it.sha)) }.
	collect {
	  it.code_repo_name = args.code_repo_name
	  it.code_github_org = args.code_github_org
	  it
	}

      // debug_dump_list("Tags", tag_list)
      // debug_dump_list("Tag shas", tag_shas)
      debug_dump_list("Branches", branch_list)
      debug_dump_list("Untagged branches", untagged_branches)

      return untagged_branches
    }
}
    

